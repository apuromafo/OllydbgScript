// Восстановление таблицы IAT и инструкций вызовов переадресованных APIs
// Разработан - vnekrilov
// Дата - 01 декабря 2008
// Установить флажки на все исключения отладчика
// Удалить все установленные breakpoints
// Скрипт тестировался только на WinXP, OllyDbg 1.10, ODBGScript 1.48 (эта версия plugin корректно обрабатывает ассемблирование инструкций)
// Поддерживает Asprotect 1.32, 1.33, ,1.35, 1.4, 2.0, 2.1, 2.11, 2.2beta, 2.2, 2.3, 2.4, 2.41

var ImageBase_Asprotect_dll                     // Переменная для хранения значения ImageBase Asprotect.dll
var ImageBase_Module                            // Переменная для хранения значения ImageBase программы
var PE_signature                                // Переменная для хранения адреса PE-signature
var SizeOfImage                                 // Переменная для хранения значения SizeOfImage 
var Resource_Table                              // Переменная для хранения адреса Resource Table
var VirtualSize_1_sec                           // Переменная для хранения значения VirtualSize 1-й секции
var VirtualAddress_1_sec                        // Переменная для хранения значения VirtualAddress 1-й секции
var VirtualSize_Asprotect_sec                   // Переменная для хранения значения VirtualSize предпоследней секции файла, в которой находятся упакованные данные программы
var VirtualAddress_Asprotect_sec                // Переменная для хранения значения VirtualAddress предпоследней секции файла, в которой находятся упакованные данные программы
var VirtualSize_last_sec                        // Переменная для хранения значения VirtualSize последней секции
var VirtualAddress_last_sec                     // Переменная для хранения значения VirtualAddress последней секции
var ver_132                                     // Переменная для хранения версии v1.32 Asprotect
var write_IAT                                   // Переменная для хранения адреса подпрограммы записи таблицы IAT
var decrypt_API                                 // Переменная для хранения адреса подпрограммы раскриптовки имен API
var Add_Call_API                                // Переменная для хранения адреса подпрограммы переадресации вызовов эмулируемых APIs
var value_EIP                                   // Переменная для хранения значения регистра EIP
var start_IAT                                   // Переменная для хранения адреса начала таблицы IAT
var end_IAT                                     // Переменная для хранения адреса конца таблицы IAT
var size_IAT                                    // Переменная для хранения размера таблицы IAT
var JNZ_Nev_DLL                                 // Переменная для хранения адреса условного прыжка при переходе на другую DLL
var Code_Nev_DLL                                // Переменная для хранения адреса кода, куда пригает условный прыжок при переходе на другую DLL
var Add_Table_IAT                               // Переменная для хранения адреса вспомогательной таблицы для записи ID-API и адресов таблицы IAT
var CRC_1                                       // Переменная для хранения адреса 1-й проверки CRC
var CRC_2                                       // Переменная для хранения адреса 2-й проверки CRC
var RETN_WRITE_IAT                              // Переменная для хранения адреса инструкции RETN
var code_origin_1                               // Переменная для хранения оригинального кода
var code_origin_2                               // Переменная для хранения оригинального кода
var code_origin_3                               // Переменная для хранения оригинального кода
var code_origin_4                               // Переменная для хранения оригинального кода
var code_origin_5                               // Переменная для хранения оригинального кода
var massive_APIS                                // Переменная для хранения адреса массива данных с эмулированными APIs
var stack_Asprotect_dll	                        // Переменная для хранения адреса вспомогательного стека Asprotect.dll
var call_const                                  // Переменная для хранения адреса назначения CALL с константой CONST, которая используется для раскриптовки ID-API 
var call_decrypt                                // Переменная для хранения адреса назначения CALL, в котором выполняется раскриптовка ID-API
var additional_call                             // Переменная для хранения вспомогательного CALL
var count_type_1                                // Переменная для хранения числа восстановленных инструкций вызовов APIs первого типа
var count_type_2                                // Переменная для хранения числа восстановленных инструкций вызовов APIs второго типа
var Flag_FF15                                   // Переменная для хранения указателя на инструкции вызова APIs с опкодом FF15 
var OEP_SBOEP_programm                          // Переменная для хранения OEP (SBOEP) программы
var Ver_141_0401                                // Переменная для хранения идентификатора версии 1.41 build 04.01 протектора
var Address_Inject                              // Переменная для хранения адреса размещения прививок
var temp_1
var temp_2
var temp_3
var temp_4
var temp_5
var temp_6

//Получение данных о секциях программы
BPHWCALL	                                // Удаляем все установленные Hardware Breakpoint
gmi eip,MODULEBASE                              // Получаем значение ImageBase программы
mov ImageBase_Module,$RESULT                    // Сохраняем значение ImageBase программы
mov temp_1,ImageBase_Module                     // Записываем в переменную temp_1 значение ImageBase программы
add temp_1,3c                                   // Переходим на адрес PE-signature
mov temp_1,[temp_1]                             // Записываем offset адрес PE-signature
add temp_1,ImageBase_Module                     // Получаем адрес PE-signature
mov PE_signature,temp_1                         // Сохраняем адрес PE-signature в переменной
add temp_1,50                                   // Получаем адрес записи SizeOfImage в PE-signature
mov SizeOfImage,[temp_1]                        // Сохраняем значение SizeOfImage
add temp_1,38                                   // Получаем адрес записи Resource Table в PE-signature
mov temp_2,[temp_1]                             // Записываем offset адреса Resource Table
add temp_2,ImageBase_Module                     // Получаем адрес Resource Table
mov Resource_Table,temp_2                       // Сохраняем адрес Resource Table 
add temp_1,70                                   // Получаем адрес начала секций в PE-signature
add temp_1,8                                    // Получаем адрес VirtualSize первой секции в PE-signature
mov VirtualSize_1_sec,[temp_1]                  // Записываем значение VirtualSize первой секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress первой секции в PE-signature  
mov VirtualAddress_1_sec,[temp_1]               // Записываем offset адреса VirtualAddress первой секции
add VirtualAddress_1_sec,ImageBase_Module       // Записываем значение адреса VirtualAddress первой секции
mov temp_1,PE_signature                         // Записываем адрес PE-signature
add temp_1,f8                                   // Получаем адрес начала секций в PE-signature
mov temp_2,[PE_signature+6]                     // Получаем значение числа секций файла в PE-signature
and temp_2,0FFFF                                // Получаем значение числа секций файла в PE-signature

last_sec:
cmp temp_2,1                                    // Сравниваем счетчик числа секций с 1 (последняя секция файла) 
je parametr_last_sec                            // Когда получаем адрес последней секции файла, прыгаем на запись ее параметров
add temp_1,28                                   // Получаем адреса начала секций в PE-signature
sub temp_2,1                                    // Переходим на следующую секцию
jmp last_sec                                    // Повторяем цикл

parametr_last_sec:
add temp_1,8                                    // Получаем адрес значения VirtualSize последней секции
mov VirtualSize_last_sec,[temp_1]               // Записываем значение VirtualSize последней секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress последней секции в PE-signature 
mov temp_3,[temp_1]                             // Записываем offset адреса VirtualAddress последней секции   
add temp_3,ImageBase_Module                     // Записываем значение адреса VirtualAddress последней секции
mov VirtualAddress_last_sec,temp_3              // Сохраняем в переменной значение адреса VirtualAddress последней секции

mov temp_1,PE_signature                         // Записываем адрес PE-signature
add temp_1,f8                                   // Получаем адрес начала секций в PE-signature
mov temp_2,[PE_signature+6]                     // Получаем значение числа секций файла в PE-signature
and temp_2,0FFFF                                // Получаем значение числа секций файла в PE-signature

Asprotect_sec:
cmp temp_2,2                                    // Сравниваем счетчик числа секций с 2 (предпоследняя секция файла) 
je parametr_Asprotect_sec                       // Когда получаем адрес предпоследней секции файла, прыгаем на запись ее параметров
add temp_1,28                                   // Получаем адреса начала секций в PE-signature
sub temp_2,1                                    // Переходим на следующую секцию
jmp Asprotect_sec                               // Повторяем цикл

parametr_Asprotect_sec:
add temp_1,8                                    // Получаем адрес значения VirtualSize предпоследней секции
mov VirtualSize_Asprotect_sec,[temp_1]          // Записываем значение VirtualSize предпоследней секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress предпоследней секции в PE-signature 
mov temp_3,[temp_1]                             // Записываем offset адреса VirtualAddress предпоследней секции   
add temp_3,ImageBase_Module                     // Записываем значение адреса VirtualAddress предпоследней секции
mov VirtualAddress_Asprotect_sec,temp_3         // Сохраняем в переменной значение адреса VirtualAddress предпоследней секции

gpa "GetSystemTime","kernel32.dll"              // Получаем адрес API GetSystemTime на нашей машине
bp $RESULT                                      // Устанавливаем bp на API GetSystemTime
esto                                            // Выполняем команду SHIFT+F9 в OllyDbg
bc eip                                          // Удаляем bp на API GetSystemTime
rtr                                             // Выполняем API GetSystemTime до инструкции RETN
sti                                             // Выходим из API GetSystemTime
GMEMI eip,MEMORYOWNER                           // Получаем значение ImageBase Asprotect.dll
mov temp_1,$RESULT                              // Сохраняем полученное значение в переменной temp_1
cmp temp_1,ImageBase_Module                     // Сравниваем полученное значение с ImageBase программы
je write_ImageBase_Asprotect_dll                // Если они равны, прыгаем на метку write_ImageBase_Asprotect_dll
mov ImageBase_Asprotect_dll,temp_1              // Сохраняем значение ImageBase Asprotect.dll
jmp next                                        // Прыгаем на продолжение работы скрипта

write_ImageBase_Asprotect_dll:
mov temp_1,VirtualAddress_Asprotect_sec         // Записываем в переменную temp_1 значение VirtualAddress предпоследней секции        
mov ImageBase_Asprotect_dll,temp_1              // Сохраняем значение ImageBase Asprotect.dll
mov Ver_141_0401,1                              // Записываем флажок 1, который указывает нам на то, что используется версия 1.41 build 04.01 протектора

next:
// Поиск подпрограмм, которые заполняют таблицу IAT при запуске программы
find ImageBase_Asprotect_dll,#40890383C704#     // Ищем группу инструкций "inc eax", "mov [ebx],eax", "add edi,4" в подпрограмме записи таблицы IAT
mov temp_1,$RESULT                              // Записываем найденный адрес в переменную temp_1
add temp_1,1                                    // Получаем адрес инструкции "mov [ebx],eax", в которой выполняется запись адреса API на соответствующее место в таблице IAT
mov write_IAT,temp_1                            // Сохраняем в переменной write_IAT адрес инструкции "mov [ebx],eax" (здесь выполняется запись адреса API на соответствующее место в таблице IAT)
bp write_IAT                                    // Устанавливаем bp на инструкции "mov [ebx],eax"
find ImageBase_Asprotect_dll,#33C08A433?3BF0#   // Ищем группу инструкций "xor eax,eax", "mov al,[ebx+3?]", "cmp esi,eax" в подпрограмме раскриптовки имен API
mov decrypt_API,$RESULT                         // Сохраняем найденный адрес в переменной decrypt_API
cmp decrypt_API,0                               // Проверяем, найдена ли подпрограмма раскриптовки имен API
je error                                        // Если нет, прыгаем на ошибку
add decrypt_API,7                               // Указываем адрес размещения прыжка в область прививки (этот прыжок записывается вместо двух инструкций "jnz xxxxxxxx" и "jmp xxxxxxxx")
find ImageBase_Asprotect_dll,#8BDF8B0385C00F85# // Ищем группу инструкций "jnz xxxxxxxx", "mov ebx,edi", "mov eax,[ebx]", "test eax,eax", "jnz xxxxxxxx" (прыжок при заполнении таблицы IAT адресами APIs из другой DLL)
mov JNZ_Nev_DLL,$RESULT                         // Сохраняем найденный адрес в переменной JNZ_Nev_DLL
cmp JNZ_Nev_DLL,0                               // Проверяем, найдена ли вышеуказанная группа инструкций
je error                                        // Если нет, прыгаем на ошибку
add JNZ_Nev_DLL,6                               // Указываем адрес расположения прыжка в область прививки (вместо инструкции "jnz xxxxxxxx")
find ImageBase_Asprotect_dll,#894424086AFF#     // Ищем группу инструкций "mov [esp+8],eax", "push -1" (сюда выполняется условный прыжок при записи адреса первой API другой DLL в таблицу IAT)
mov Code_Nev_DLL,$RESULT                        // Сохраняем полученный адрес в переменной Code_Nev_DLL
cmp Code_Nev_DLL,0                              // Проверяем, найдена ли вышеуказанная группа инструкций
je error                                        // Если нет, прыгаем на ошибку
find ImageBase_Asprotect_dll,#45894500#         // Ищем группу инструкций "inc ebp", "mov [ebp],eax", которые находятся в конце подпрограммы заполнения таблицы IAT
mov temp_2,$RESULT                              // Записываем найденный адрес в переменную temp_2
cmp temp_2,0                                    // Проверяем, найдена ли вышеуказанная группа инструкций
je error                                        // Если нет, прыгаем на ошибку
sub temp_2,27                                   // Вычитаем из найденного адреса 27 байтов, чтобы найти адрес указателя на массив API
mov Add_Call_API,temp_2                         // Записываем полученное значение в переменную Add_Call_API
esto                                            // Выполняем команду SHIFT+F9 в OllyDbg
cmp eip,write_IAT                               // Проверяем, остановились ли мы на адресе инструкции "mov [ebx],eax"
jne error                                       // Если нет, прыгаем на ошибку
bc write_IAT                                    // Удаляем bp
mov temp_2,[decrypt_API-3],1                    // Записываем в переменную temp_2 значение "3?" из инструкции "mov al,[ebx+3?]"
cmp temp_2,3F                                   // Проверяем, не равно ли это значение 3Fh
jne vrite_origin_code                           // Если не равно, то прыгаем на метку vrite_origin_code
mov ver_132,1                                   // Если равно, то в переменную ver_132 записываем 1

// Сохраняем оригинальные байты опкода инструкций, на месте которых будут записаны прыжки в код прививки
vrite_origin_code:
mov code_origin_1,[decrypt_API]                 // Сохраняем оригинальные байты опкода инструкций "jnz xxxxxxxx" и "jmp xxxxxxxx"
mov code_origin_2,[decrypt_API+4]               // Сохраняем оригинальные байты опкода инструкции "mov ax,word [edx]"
mov code_origin_5,[JNZ_Nev_DLL+2]               // Сохраняем оригинальные байты опкода адреса назначения инструкции "jnz xxxxxxxx"
mov temp_1,[ebx]                                // Записываем в переменную temp_1 адрес начала таблицы IAT
add temp_1,ImageBase_Module                     // Прибавляем к адресу начала таблицы IAT значение ImageBase программы
mov start_IAT,temp_1                            // Сохраняем значение адреса начала таблицы IAT в переменной start_IAT
find eip,#8A042483C40C5D5F5E5BC3#               // Ищем конец подпрограммы записи таблицы IAT (группу инструкций "mov al,byte [esp]", "add esp,0c", "pop ebp", "pop edi", "pop esi", "pop ebx", "retn")
mov temp_1,$RESULT                              // Записываем полученный адрес конца подпрограммы записи таблицы IAT в переменную temp_1 
cmp temp_1,0                                    // Проверяем, найден ли конец подпрограммы записи таблицы IAT
je error                                        // Если нет, прыгаем на ошибку
add temp_1,0a                                   // Указываем адрес инструкции RETN подпрограммы записи таблицы IAT
mov RETN_WRITE_IAT,temp_1                       // Сохраняем адрес инструкции RETN в переменной RETN_WRITE_IAT
mov value_EIP,eip                               // Сохраняем значение регистра EIP в переменной value_EIP

// Запись прививки для восстановления закриптованных имен APIs
alloc 2000                                      // Создаем область памяти для размещения кода привовок
mov Address_Inject,$RESULT                      // Записываем в переменную полученный адрес созданной области памяти
mov temp_1,Address_Inject                       // Записываем в переменную temp_1 адрес области памяти для размещения кода привовок
cmp ver_132,1                                   // Проверяем, с какой версией Asprotect.dll мы работаем
je write_inject_1                               // Если не равно, то записываем эту прививку 
mov [temp_1],#5751558BAC2440010000892D001040000FB67B353BF775240FB673368BFA83EF0233C9668B0F8B3D00104000890F83C704892F83C70C893D001040005D595F3BF00F8500000000E90000000090909090578B3D0000010483C704C707000000005FE900000000909090#
jmp pathing_inject                              // Прыгаем на корректировку прививки

write_inject_1:
mov [temp_1],#5751558BAC2440010000892D001040000FB67B393BF775240FB6733A8BFA83EF0233C9668B0F8B3D00104000890F83C704892F83C70C893D001040005D595F3BF00F8500000000E90000000090909090578B3D0000010483C704C707000000005FE900000000909090#

// Корректировка кодов прививки и подпрограммы записи таблицы IAT
pathing_inject:
add temp_1,41                                   // Указываем в прививке адрес расположения условного прыжка в подпрограмму раскриптовки имен APIs
mov temp_2,decrypt_API                          // Записываем в переменную temp_2 адрес нахождения инструкции "jnz xxxxxxxx"
add temp_2,60                                   // Получаем адрес назначения условного прыжка "jnz xxxxxxxx"
eval "jnz {temp_2}"                             // Оцениваем полученное значение адреса назначения условного прыжка
asm temp_1,$RESULT                              // Записываем в прививке условный прыжок на полученный адрес назначения
add temp_1,6                                    // Указываем в прививке адрес для записи безусловного прыжка в подпрограмму раскриптовки имен APIs                       
mov temp_2,decrypt_API                          // Записываем в переменную temp_2 адрес нахождения инструкции "jnz xxxxxxxx"
add temp_2,5                                    // Получаем адрес назначения безусловного прыжка "jmp xxxxxxxx"
eval "jmp {temp_2}"                             // Оцениваем полученное значение адреса назначения безусловного прыжка
asm temp_1,$RESULT                              // Записываем в прививке безусловный прыжок на полученный адрес
eval "jmp {Address_Inject}"                     // Оцениваем значение прыжка из области кода на начало прививки 
asm decrypt_API,$RESULT                         // Записываем прыжок на начало прививки в коде подпрограммы раскриптовки имен APIs

// Устранение проверок CRC в коде подпрограммы записи таблицы IAT
find decrypt_API,#3B432?74656AFF#               // Ищем 1-ю проверку целостности кода CRC в подпрограмме раскриптовки имен APIs
mov CRC_1,$RESULT                               // Записываем найденный адрес в переменную CRC_1
cmp CRC_1,0                                     // Проверяем, найдена ли подпрограмма проверки целостности кода CRC
je check_CRC_2                                  // Если нет, прыгаем на поиск следующей проверки целостности кода CRC
add CRC_1,3                                     // Указываем адрес расположения условного прыжка "je xxxxxxxx"
mov code_origin_3,[CRC_1]                       // Сохраняем оригинальный опкод инструкции "je xxxxxxxx"
mov [CRC_1],#EB#                                // Заменяем условный прыжок "je" безусловным прыжком "jmp"

check_CRC_2:
find decrypt_API,#3B432?741B6AFF#               // Ищем 2-ю проверку целостности кода CRC в подпрограмме раскриптовки имен APIs
mov CRC_2,$RESULT                               // Записываем найденный адрес в переменную CRC_2
cmp CRC_2,0                                     // Проверяем, найдена ли подпрограмма проверки целостности кода CRC
je error                                        // Если нет, прыгаем на ошибку
add CRC_2,3                                     // Указываем адрес расположения условного прыжка "je xxxxxxxx"
mov code_origin_4,[CRC_2]                       // Сохраняем оригинальный опкод инструкции "je xxxxxxxx"
mov [CRC_2],#EB#                                // Заменяем условный прыжок "je" безусловным прыжком "jmp"
mov temp_1,Address_Inject                       // Записываем в переменную значение Address_Inject
add temp_1,0a                                   // Указываем в прививке адрес расположения инструкции, где записывается текущий восстанавливаемый адрес таблицы IAT
mov temp_2,Address_Inject                       // Записываем в переменную значение Address_Inject
add temp_2,74                                   // Указываем адрес памяти для записи текущего восстановленного адреса таблицы IAT расположим по смещению 74h байтов от начала Asprotect.dll
eval "mov [{temp_2}],ebp"                       // Оцениваем полученное значение
asm temp_1,$RESULT                              // Записываем полученный код в прививку по адресу 0Ah
add temp_1,1c                                   // Указываем в прививке адрес расположения инструкции, где записываются данные о вспомогательной таблице (запись ID-API для закриптованных APIs)
mov temp_2,Address_Inject                       // Записываем в переменную значение Address_Inject 
add temp_2,70                                   // Указываем адрес памяти для записи данных о вспомогательной таблице расположим по смещению 70h от начала Asprotect.dll
eval "mov edi,[{temp_2}]"                       // Оцениваем полученное значение
asm temp_1,$RESULT                              // Записываем полученный код в прививку по адресу 26h
add temp_1,10                                   // Указываем в прививке адрес расположени инструкции, где записываются данные о вспомогательной таблице (запись адреса в таблице IAT для закриптованных APIs)
mov temp_2,Address_Inject                       // Записываем в переменную значение Address_Inject
add temp_2,70                                   // Указываем адрес памяти для хранения данных о вспомогательной таблице (смещение 70h от начала Asprotect.dll)
eval "mov [{temp_2}],edi"                       // Оцениваем полученное значение
asm temp_1,$RESULT                              // Записываем полученный код в прививку по адресу 36h
add temp_1,1b                                   // Указываем в прививке адрес расположения инструкции, где записывается текущий восстановленный адрес таблицы IAT
mov temp_2,Address_Inject                       // Записываем в переменную значение Address_Inject 
add temp_2,74                                   // Адрес памяти для записи текущего восстановленного адреса таблицы IAT расположим по смещению 74h байтов от начала Asprotect.dll
eval "mov edi,[{temp_2}]"                       // Оцениваем полученное значение
asm temp_1,$RESULT                              // Записываем полученный код в прививку по адресу 51h
add temp_1,10                                   // Указываем в прививке адрес инструкции, где записывается условный прыжок при переходе на другую DLL в таблице IAT
mov temp_3,Code_Nev_DLL                         // Записываем в переменную temp_3 адрес кода, куда должен быть выполнен условный прыжок при переходе на другую DLL в таблице IAT
eval "jmp {temp_3}"                             // Оцениваем полученное значение
asm temp_1,$RESULT                              // Записываем полученный код в прививку по адресу 5Eh
mov temp_2,Address_Inject                       // Записываем в переменную значение Address_Inject
add temp_2,50                                   // Указываем адрес в прививке, где в таблицу IAT будут записываться разделительные ноли между блоками DLL
eval "jnz {temp_2}"                             // Оцениваем полученное значение
asm JNZ_Nev_DLL,$RESULT                         // Записываем полученный код на месте расположения условного прыжка "jnz xxxxxxxx" 

// Создаем область памяти для вспомогательной таблицы, в которой записываются ID-API и адреса в таблице IAT, 
// на которых находятся эмулируемые APIs, и записываем ее в прививку
alloc 2000                                      // Создаем область памяти для размещения прививки и необходимых данных
mov Add_Table_IAT,$RESULT                       // Записываем адрес созданной области памяти в переменную Collection_Memory
mov temp_1,Address_Inject                       // Копируем в переменную temp_1 значение Address_Inject
add temp_1,70                                   // Указываем в прививке адрес расположения инструкции, где записывается начальный адрес вспомогательной таблицы
mov [temp_1],Add_Table_IAT                      // Записываем в прививку данные о начальном адресе вспомогательной таблицы

// Процесс восстановления таблицы IAT
bp RETN_WRITE_IAT                               // Устанавливаем bp на инструкцию RETN подпрограммы записи таблицы IAT
run                                             // Запускаем программу
cmp eip,RETN_WRITE_IAT                          // Проверяем, остановились ли мы на инструкции RETN подпрограммы записи таблицы IAT
jne error                                       // Если НЕТ, то прыгаем на ошибку
bc eip                                          // Удаляем bp с инструкции RETN

// Получение информации об основных данных таблицы IAT
mov temp_1,Address_Inject                       // Записываем в переменную значение Address_Inject 
add temp_1,74                                   // Указываем адрес области памяти, в которой записываются адреса восстановленной таблицы IAT (смещение 64h байтов от начала Asprotect.dll)
mov end_IAT,[temp_1]                            // Записываем в переменную end_IAT последний восстановленный адрес таблицы IAT
mov temp_1,end_IAT                              // Записываем в переменную temp_1 адрес конца таблицы IAT 
sub temp_1,start_IAT                            // Вычисляем размер таблицы IAT
add temp_1,4                                    // Прибавляем последние разделительные нули в конце таблицы IAT
mov size_IAT,temp_1                             // Сохраняем в переменной size_IAT размер таблицы IAT
mov temp_1,end_IAT                              // Записываем в переменную temp_1 адрес конца таблицы IAT
add temp_1,4                                    // Прибавляем последние разделительные нули в конце таблицы IAT
mov [temp_1],0                                  // Записываем разделительные ноли в конце таблицы IAT

// Получение дампа таблицы IAT и вспомогательной таблицы
dm start_IAT,size_IAT,"table_IAT.bin"           // Выполняем дампирование таблицы IAT
dm Add_Table_IAT,900,"add_table_IAT.bin"        // Выполняем дампирование вспомогательной таблицы

// Восстановление исходного кода в пропатченных адресах Asprotect.dll
fill Address_Inject,80,00                       // Заполняем нолями начало области Address_Inject
mov temp_1,decrypt_API                          // Копируем в переменную temp_1 адрес размещения инструкции "jnz xxxxxxxx" и "jmp xxxxxxxx"
mov [decrypt_API],code_origin_1                 // Восстанавливаем оригинальные байты опкода по адресу расположения инструкции "jnz xxxxxxxx" и "jmp xxxxxxxx"
add temp_1,4                                    // Переходим на следующие 4 байта опкода
mov [temp_1],code_origin_2                      // Восстанавливаем следуюшщие 4 оригинальных байтов инструкции "mov ax,word [edx]"
mov temp_1,JNZ_Nev_DLL                          // В переменную temp_1 записываем адрес расположения условного прыжка "jnz xxxxxxxx"
add temp_1,2                                    // Смещаемся на 2 байта, где записан опкод адреса назначения условного прыжка
mov [temp_1],code_origin_5                      // Восстанавливаем код условного прыжка "jnz xxxxxxxx"
cmp [CRC_1],0                                   // Проверяем, содержит ли CRC_1 байты оригинального опкода
je recovery_CRC_2                               // Усли нет байтов опкода, прыгаем на recovery_CRC_2
mov [CRC_1],code_origin_3                       // Восстанавливаем оригинальные байты опкода по адресу размещения прыжка для обхода 1-й проверки CRC кода

recovery_CRC_2:
mov [CRC_2],code_origin_4                       // Восстанавливаем оригинальные байты опкода по адресу размещения прыжка для обхода 2-й проверки CRC кода

// Поиск адреса массива с данными об эмулированных APIs
find ImageBase_Asprotect_dll, #8B432C2BC583E805# // Ищем группу инструкций "mov eax,[ebx+2c]", "sub eax,ebp", "sub eax,5" в подпрограмме записи CALL для вызова эмулированных APIs
mov temp_1,$RESULT                              // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                    // Проверяем, найдена ли эта группа инструкций
je error                                        // Если нет, прыгаем на ошибку
add temp_1,8                                    // Вычисляем адрес инструкции "inc ebp"
bphws temp_1,"x"                                // Устанавливаем Hardware BreakPoint на адрес этой инструкции
mov massive_APIS,0                              // Записываем начальный 0 в переменную massive_APIS

// Поиск проверки CRC после восстановления таблицы IAT и записи вспомогательной таблицы
find ImageBase_Asprotect_dll,#2BD003F2EB01#     // Ищем группу инструкций "sub edx,eax", "add esi,edx", "jmp xxxxxxxx"
mov temp_2,$RESULT                              // Записываем результат поиска в переменную temp_1
cmp temp_2,0                                    // Проверяем, найдена ли эта группа инструкций
je find_CRC_1                                   // Если нет, то прыгаем на поиск последней проверки целостности кода (CRC) перед OEP
add temp_2,7                                    // Определяем адрес инструкции "test esi,esi"
bphws temp_2,"x"                                // Устанавливаем bp на адрес этой инструкции

// Поиск последней проверки целостности кода (CRC) перед прохождением на OEP
find_CRC_1:
mov temp_3,ImageBase_Asprotect_dll              // Копируем в переменную значение ImageBase Asprotect.dll
add temp_3,1000                                 // Смещаемся на величину заголовка Asprotect.dll
find temp_3,#C6463401#                          // Ищем инструкцию "mov byte [esi+34],1" 
mov temp_4,$RESULT                              // Записываем адрес этой инструкции в переменную temp_2
cmp temp_4,0                                    // Проверяем, найдена ли эта инструкция
je error                                        // Если нет, прыгаем на ошибку
find temp_4,#68????????68????????68#            // Ищем подпрограмму проверки целостности кода CRC
mov CRC_1,$RESULT                               // Записываем адрес подпрограммы в переменную
cmp CRC_1,0                                     // Проверяем, найдена ли подпрограмма проверки целостности кода CRC
je error                                        // Если нет, прыгаем на ошибку
bp CRC_1                                        // Устанавливаем bp на подпрограмму проверки целостности кода CRC

// Запись адреса расположения массива данных об эмулированных инструкциях и устранение проверки CRC 
run                                             // Запускаем программу
cmp eip,temp_1                                  // Проверяем, осталовились ли мы на подпрограмме записи CALL для вызова эмулированных APIs
je write_massive_APIS                           // Если ДА, то прыгаем на запись адреса массива данных в переменную massive_APIS
cmp eip,temp_2                                  // Если НЕТ, то проверяем, остановлись ли мы проверке CRC после восстановления таблицы IAT и записи вспомогательной таблицы
je fix_CRC                                      // Если Да, то прыгаем на исправление значения в регистре ESI
cmp eip,CRC_1                                   // Если НЕТ, то прыгаем метку go_to_OEP
jmp go_to_OEP                                   // Прыгаем на метку go_to_OEP, чтобы продолжить работу скрипта

write_massive_APIS:
bphwc eip                                       // Удаляем Hardware BreakPoint 
mov massive_APIS,ebx                            // Записываем адрес таблицы, управляющей извлечением информации из массива данных
run                                             // Запускаем программу

fix_CRC:
cmp eip,temp_2                                  // Если ДА, то проходим на исправление значения в регистре ESI
jne go_to_OEP                                   // Если НЕТ, то прыгаем на метку go_to_OEP
bc eip                                          // Удаляем установленную bp
mov esi,0                                       // Обнуляем значение регистра ESI

go_to_CRC_1:
run                                             // Запускаем программу

go_to_OEP:
cmp eip,CRC_1                                   // Если ДА, то подолжаем работу скрипта
jne go_to_CRC_1                                 // Если НЕТ, то прыгаем метку go_to_CRC_1
bphwc temp_1                                    // Удаляем Hardware bp с подпрограммы записи CALL для вызова эмулированных APIs
bc temp_2                                       // Удаляем bp с проверки CRC после восстановления таблицы IAT и записи вспомогательной таблицы
bc CRC_1                                        // Удаляем bp с проверки CRC_1

// Прохождение на OEP программы
mov temp_1,ImageBase_Asprotect_dll              // Копируем в переменную значение ImageBase Asprotect.dll
add temp_1,1000                                 // Смещаемся на величину заголовка Asprotect.dll
find temp_1,#3135330D0A#                        // Ищем строку ASCII "153" 
mov temp_2,$RESULT                              // Записываем адрес этой строки в переменную temp_2
sub temp_2,40                                   // Смещаемся вверх на 40 байтов
find temp_2,#5?5?C3#                            // Ищем группу инструкций "pop e?x", "pop e?x", "retn" в конце подпрограммы
mov temp_3,$RESULT                              // Записываем адрес группы инструкций в переменную temp_3
cmp temp_3,0                                    // Проверяем, найдена ли эта группа инструкций
je error                                        // Если нет, прыгаем на ошибку
add temp_3,2                                    // Прибавляем к найденному адресу 2 байта, чтобы получить адрес инструкции RETN
rtr                                             // Выполняем подпрограмму проверки CRC до инструкции RETN
bp temp_3                                       // Устанавливаем bp на найденный адрес инструкции RETN
run                                             // Запускаем программу
bc eip                                          // Удаляем bp
mov temp_1,ImageBase_Asprotect_dll              // Копируем в переменную значение ImageBase Asprotect.dll
add temp_1,1000                                 // Смещаемся на величину заголовка Asprotect.dll
find temp_1,#3130330D0A#                        // Ищем строку ASCII "103"
mov temp_2,$RESULT                              // Записываем адрес этой цепочки байтов в переменную temp_2
cmp temp_2,0                                    // Проверяем, найдена ли эта строка
je error                                        // Если нет, прыгаем на ошибку
find temp_2,#8D00C3#                            // Ищем инструкции "lea eax,[eax]", "retn", которые расположены ниже строки ASCII "103"
mov temp_1,$RESULT                              // Записываем адрес этой группы инструкций в переменную temp_2
cmp temp_1,0                                    // Проверяем, найдена ли эта группа инструкций
je error                                        // Если НЕТ, прыгаем на ошибку
bphws temp_1,"x"                                // Устанавливаем Hardware BreakPoint на адрес этой группы инструкций
run                                             // Запускаем программу
bphwc eip                                       // Удаляем Hardware BreakPoint
find eip, #C700E1000000#                        // Ищем строку ASCII "3.6"
mov temp_1,$RESULT                              // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                    // Проверяем, найдена ли эта строка
jne search_SBOEP                                // Если строка найдена, то прыгаем на метку search_SBOEP
find eip,#C600E1#                               // Если строка не найдена, то ищем инструкцию "mov byte:[eax],0e1"
mov temp_1,$RESULT                              // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                    // Проверяем, найдена ли эта строка
je error                                        // Если НЕТ, прыгаем на ошибку

search_SBOEP:
find temp_1, #A1????????894?#                   // Ищем группу инструкций "mov eax,[const]", "mov [e?p+??],reg32"
mov temp_3,$RESULT                              // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                    // Проверяем, найдена ли эта группа инструкций
je error                                        // Если НЕТ, прыгаем на ошибку
mov temp_2,0                                    // Обнуляем переменную temp_2
mov temp_2,[temp_3+1]                           // Записываем адрес const в переменную temp_2 (содержимое const содержит адрес SBOEP)
mov temp_1,[temp_2]                             // Записываем содержимое [const] в переменную temp_2
cmp temp_1,0                                    // Проверяем, не записан ли здесь 0 (если записан 0, то код OEP не украден, и программа не имеет SBOEP)
jne SBOEP                                       // Если записано значение SBOEP, то прыгаем на метку SBOEP

NO_SBOEP:
rtr                                             // Выполняем подпрограмму до инструкции RETN
sti                                             // Выполняем инструкцию RETN
GMEMI eip,MEMORYOWNER                           // Получаем адрес памяти, где мы оказались после выполнения инструкции RETN
mov temp_3,$RESULT                              // Полученный результат записываем в переменную temp_3
mov temp_2,VirtualAddress_last_sec              // В переменную temp_2 записываем значение VirtualAddress_last_sec 
add temp_2,VirtualSize_last_sec                 // К этому значению прибавляем значение VirtualSize_last_sec
cmp temp_3,temp_2                               // Проверяем, значение temp_3 больше или меньше значения temp_2
ja NO_SBOEP_1                                   // Если больше, то прыгаем на метку NO_SBOEP_1
cmp VirtualAddress_1_sec,temp_3                 // Если меньше, то сравниваем значения VirtualAddress_1_sec и temp_3
jb error                                        // Если VirtualSize_1_sec > temp_3, то прыгаем на ошибку
GMEMI eip,MEMORYSIZE                            // Получаем размер области памяти, где мы оказались после выполнения инструкции RETN
mov temp_1,$RESULT                              // Полученное значение записываем в переменную temp_1
add temp_3,temp_1                               // Суммируем значения temp_3 и temp_1
eval "eip > 0{temp_3}"                          // Получаем условие cnd, при котором оно будет TRUE
jmp NO_SBOEP_2                                  // Прыгаем на метку NO_SBOEP_2

NO_SBOEP_1:
eval "eip < 0{temp_3}"                          // Получаем условие cnd, при котором оно будет TRUE

NO_SBOEP_2:
ticnd $RESULT                                   // Трассируем into calls до появления условия cnd TRUE
mov temp_1,eip                                  // Записываем полученный адрес OEP в переменную temp_1
log temp_1,"Адрес OEP - "                       // Записываем адрес OEP в журнал регистрации
jmp recovery_IAT                                // Прыгаем на завершение работы этой части скрипта

SBOEP:
bp temp_1                                       // Устанавливаем bp на адрес SBOEP
run                                             // Запускаем программу

SBOEP_1:
cmp eip,temp_1                                  // Проверяем, остановились ли мы на bp
je SBOEP_2                                      // Если ДА, то прыгаем на метку SBOEP_2
run                                             // Если НЕТ, то опять запускаем программу

SBOEP_2:
bc temp_1                                       // Удаляем bp
mov temp_1,eip                                  // Записываем полученный адрес SBOEP в переменную temp_1
log temp_1,"Адрес SBOEP - "                     // Записываем адрес SBOEP в журнал регистрации
jmp recovery_IAT                                // Прыгаем на завершение работы этой части скрипта

error:
msg "Ошибка! Для ее выявления, выполните трассирование скрипта!"  // Выводим сообщение об ошибке
pause                                           // Пауза в работе скрипта
ret                                             // Завершаем работу скрипта 

recovery_IAT:
// Запись в буфер памяти журнал OllyDbg основных значений для ImpREC и скрипта для восстановления вызовов APIs
mov temp_1,ImageBase_Asprotect_dll              // Копируем в переменную значение ImageBase Asprotect.dll
add temp_1,0f80                                 // Смещаемся на F80 от начала заголовка Asprotect.dll
mov [temp_1],ImageBase_Asprotect_dll            // По адресу +0F80 записываем значение ImageBase Asprotect.dll
add temp_1,4                                    // Смещаемся на следующую ячейку буфера памяти
mov [temp_1],VirtualAddress_1_sec               // По адресу 0F80+4 записываем значение VirtualAddress 1-й секции
add temp_1,4                                    // Смещаемся на следующую ячейку буфера памяти
mov [temp_1],VirtualSize_1_sec                  // По адресу 0F80+8 записываем значение VirtualSize 1-й секции
add temp_1,4                                    // Смещаемся на следующую ячейку буфера памяти
mov [temp_1],massive_APIS                       // По адресу 0F80+0C записываем значение адреса массива данных с эмулированными APIs
add temp_1,4                                    // Смещаемся на следующую ячейку буфера памяти
mov [temp_1],Add_Table_IAT                      // По адресу 0F80+10 записываем значение вспомогательной таблицы для записи ID-API и адресов таблицы IAT
add temp_1,4                                    // Смещаемся на следующую ячейку буфера памяти
mov [temp_1],size_IAT                           // По адресу 0F80+14 записываем значение размера таблицы IAT

log ImageBase_Asprotect_dll,"Адрес начала AsProtect.dll - "       // Записываем в журнал регистрации ImageBase Asprotect.dll
log OEP_SBOEP_programm,"Адрес OEP (SBOEP) программы - "           // Записываем адрес OEP в журнал регистрации
log VirtualAddress_1_sec,"Адрес секции кода программы - "         // Записываем в журнал адрес секции кода программы
log VirtualSize_1_sec,"Размер секции кода программы - "           // Записываем в журнал размер секции кода программы
log Add_Table_IAT,"Адрес вспомогательной таблицы - "              // Записываем в журнал адрес вспомогательной таблицы
log start_IAT,"Адрес начала таблицы IAT - "                       // Записываем в журнал адрес начала таблицы IAT
mov temp_1,start_IAT                                              // Записываем в переменную temp_1 адрес начала таблицы IAT
sub temp_1,ImageBase_Module                                       // Вычисляем offset начала таблицы IAT
log temp_1,"Адрес начала таблицы IAT для ImpREC - "               // Записываем в журнал значение offset начала таблицы IAT для Import Reconstructor
log end_IAT,"Адрес конца таблицы IAT - "                          // Записываем в журнал адрес конца таблицы IAT
log size_IAT,"Размер таблицы IAT для ImpREC - "                   // Записываем в журнал адрес конца таблицы IAT
cmp massive_APIS,0                                                // Проверяем, записан ли адрес массива данных об APIs
je no_recovery_CALL_APIs                                          // Если НЕТ, то прыгаем на метку no_recovery_CALL_APIs
log massive_APIS,"Адрес массива данных для эмулируемых APIs - "   // Записываем адрес массива данных для эмулируемых APIs в журнал регистрации

// Восстановление оригинальных инструкций вызовов APIs в коде программы

// Восстановление инструкций вызова APIs второго типа
mov temp_4,Add_Call_API                                           // Записываем в переменную temp_4 значение Add_Call_API
sub temp_4,100                                                    // Вычитаем из этого значения 100h байтов
find temp_4,#05FF000000508BC3#                                    // Ищем инструкции "add eax,off", "push eax", "mov eax,ebx"
mov temp_1,$RESULT                                                // Найденный адрес инструкций записываем в переменную 
cmp temp_1,0                                                      // Проверяем, найдены ли эти инструкции
je error                                                          // Если НЕТ, то прыгаем на ошибку
add temp_1,8                                                      // Смещаемся вниз на 8h байтов
opcode temp_1                                                     // Получаем опкод инструкции CALL
mov call_const,$RESULT_1                                          // Записываем инструкцию CALL в переменную call_const
add temp_1,5                                                      // Смещаемся вниз на 05h байтов
find temp_1,#8BC3E8??#                                            // Ищем инструкции "mov eax,ebx", "call xxxxxxxx" 
mov temp_2,$RESULT                                                // Найденный адрес записываем в переменную 
cmp temp_2,0                                                      // Проверяем, найдены ли эти инструкции
je error                                                          // Если НЕТ, то прыгаем на ошибку
add temp_2,2                                                      // Смещаемся вниз на 2 байта
opcode temp_2                                                     // Получаем опкод инструкции CALL
mov call_decrypt,$RESULT_1                                        // Записываем инструкцию CALL в переменную call_decrypt
add temp_2,5                                                      // Смещаемся на 5h байтов
find temp_2,#8BC3E8??#                                            // Ищем инструкции "mov eax,ebx", "call xxxxxxxx" 
mov temp_1,$RESULT                                                // Найденный адрес записываем в переменную 
cmp temp_1,0                                                      // Проверяем, найдены ли эти инструкции
je error                                                          // Если НЕТ, то прыгаем на ошибку
add temp_1,2                                                      // Смещаемся вниз на 2 байта
mov temp_3,[temp_1-D],1                                           // Записываем в переменную байт, находящийся по адресу tmp1-D
cmp temp_3,50                                                     // Сравниваем его со значением 50h
je write_Flag_FF15                                                // Если они равны, то прыгаем на запись Flag_FF15
mov ver_132,1                                                     // Если они не равны, то у нас версия 1.32

write_Flag_FF15:
mov temp_1,massive_APIS                                           // Записываем в переменную temp_1 адрес массива данных
add temp_1,4a                                                     // Смещаемся в массиве данных на 4Ah байтов
mov temp_2,[temp_1],1                                             // Записываем в переменную temp_2 значение байта, находящегося по этому адресу
add temp_1,1                                                      // Смещаемся в массиве данных на следующий байт
mov temp_3,[temp_1],1                                             // Записываем в переменную temp_3 значение байта, находящегося по этому адресу
cmp temp_2,temp_3                                                 // Сравниваем эти значения
je write_Flag_FF15_1                                              // Если они равны, прыгаем на метку write_Flag_FF15_1
mov Flag_FF15,0                                                   // Если они не равны, инструкции вызова APIs содержат опкод FF25
jmp write_code_1                                                  // Продолжаем выполнение скрипта

write_Flag_FF15_1: 
mov Flag_FF15,1                                                   // Если они равны, инструкции вызова APIs содержат опкод FF15

write_code_1:
fill Address_Inject,900,00                                        // Заполняем нолями начало области кода прививок
mov temp_1,Address_Inject                                         // Копируем в переменную temp_1 значение Address_Inject

// Патч 1
mov [temp_1],#60BB00104000BD001040008B73548D7B408B43188945608B83E000000089453433C08A078D04408B4C83688BC6FFD18BC8034B24038BE000000033C08A47098D04408B5483688BC6FFD2807B20000F854C0100003C010F8544010000894D7033C08A47078D04408B5483688BC6FFD289452433C08A47088D04408B5483688BC6FFD289452833C08A47028D04408B5483688BC6FFD289453C33C08A47068D04408B5483688BC6FFD28845408B83E000000001453C8B453C5033C08A454005FF000000508BC3E85A6A03008BC88B53108BC3E8725803008B5524035534#
// Патч 2
add temp_1,0dc
mov [temp_1],#03D08955248B55282B55342BD089552833C08A47038D04408B5483688BC6FFD28945348B83E000000001453433C08A47018D04408B5483688BC6FFD28845388D452C508B5528589090909090909090909090909090909090909090909090909060E82E000000B9FF1500008B457066890883C002893061EB48909090909090909090909090909090909090909090909090909090BEE02150003916740D83C61081FE3C2A0210770FEBEF83C6048B36C39090909090909090909090909090909090FF4568FF4D6003B3E4000000837D60000F876DFEFFFF61909090909090909090#

mov temp_1,Address_Inject                                          // Копируем в переменную temp_1 значение Address_Inject
mov temp_2,Address_Inject                                          // Копируем в переменную temp_2 значение Address_Inject
add temp_2,0d00                                                    // Указываем адрес вспомогательного буфера памяти для работы прививки                            
mov temp_3,Address_Inject                                          // Копируем в переменную temp_3 значение Address_Inject
add temp_3,0d68                                                    // Указываем область памяти для записи числа восстановленных инструкций вызовов APIs второго типа
add temp_1,2                                                       // Смещаеся на 2 байта
mov [temp_1],massive_APIS                                          // Записываем в прививку адрес массива данных для инструкций вызовов эмулируемых APIs
add temp_1,5                                                       // Смещаемся на 5h байтов
mov [temp_1],temp_2                                                // Записываем в прививку адрес вспомогательного буфера памяти 
add temp_1,0be                                                     // Смещаемся на 0BEh байтов
eval "{call_const}"                                                // Оцениваем данные, записанные в переменной call_const
asm temp_1,$RESULT                                                 // Полученный результат записываем в прививку
add temp_1,0c                                                      // Смещаемся на 0Сh байтов
eval "{call_decrypt}"                                              // Оцениваем данные, записанные в переменной call_decrypt
asm temp_1,$RESULT                                                 // Полученный результат записываем в прививку
add temp_1,0a0                                                     // Смещаемся на 0A0h байтов
mov [temp_1],Add_Table_IAT                                         // Записываем в прививку начальный адрес вспомогательной таблицы
add temp_1,0d                                                      // Смещаемся на 0Dh байтов
mov temp_2,Add_Table_IAT                                           // Копируем в переменную temp_2 начальный адрес вспомогательной таблицы
add temp_2,size_IAT                                                // Получаем адрес конца поиска значений во вспомогательной таблицы
mov [temp_1],temp_2                                                // Записываем в прививку конечный адрес вспомогательной таблицы
mov temp_3,Address_Inject                                          // Копируем в переменную temp_3 значение Address_Inject
add temp_3,143                                                     // Указываем адрес записи байтов опкода
cmp Flag_FF15,0                                                    // Проверяем значение переменной Flag_FF15
jne write_Flag_FF15_2                                              // Если здесь записана 1, то прыгаем на метку write_Flag_FF15_2
mov [temp_3],25ff                                                  // Записываем байты опкода FF25
jmp write_bp                                                       // Прыгаем на продолжение корректировки прививки

write_Flag_FF15_2:
mov [temp_3],15ff                                                  // Записываем байты опкода FF15

write_bp:
mov temp_2,Address_Inject                                          // Записываем в переменную temp_2 значение Address_Inject
add temp_2,193                                                     // Указываем адрес для установки bp при завершении работы прививки
bp temp_2                                                          // Устанавливаем bp на этом адресе
mov temp_3,Address_Inject                                          // Записываем в переменную temp_2 значение Address_Inject
add temp_3,1b4                                                     // Указываем адрес для установки bp при завершении работы прививки
bp temp_3                                                          // Устанавливаем bp на этом адресе
mov temp_4,eip                                                     // Сохраняем значение OEP (SBOEP)
cmp ver_132,1                                                      // Проверяем, не работаем ли мы с версией Asprotect 1.32 
jne run_code_1                                                     // Если НЕТ, прыгаем на запуск прививки
mov temp_1,Address_Inject                                          // Копируем в переменную temp_1 значение Address_Inject
add temp_1,11b                                                     // Смещаемся на 11Bh байтов
mov [temp_1],#90909090#                                            // Корректируем код прививки

run_code_1:
mov eip,Address_Inject                                             // Записываем в регистр EIP начало кода прививки
run                                                                // Запускаем программу
cmp eip,temp_2                                                     // Если программа остановилась здесь
je alarm                                                           // Прыгаем на сообщение о сбое в работе прививки
cmp eip,temp_3                                                     // Если остановились здесь, прививка нормально отработала
je finish_code_1                                                   // Прыгаем на завершение работы прививки
jmp error

finish_code_1:
bc temp_2                                                          // Удаляем установленную bp
bc temp_3                                                          // Удаляем установленную bp
mov temp_1,Address_Inject                                          // Копируем в переменную temp_1 значение Address_Inject
add temp_1,0d68                                                    // Указываем область памяти, в которой записано число восстановленных инструкций вызовов APIs второго типа
mov count_type_2,[temp_1]                                          // Записываем в переменную count_type_2 число восстановленных инструкций вызовов APIs второго типа
fill Address_Inject,900,00                                         // Удаляем код прививки
mov eip,temp_4                                                     // Восстанавливаем значение OEP (SBOEP)

// Восстановление инструкций вызова APIs первого типа

// Запись прививки для восстановления вызовов API
mov temp_1,Address_Inject                                          // Копируем в переменную temp_1 значение Address_Inject

// Патч 1
mov [temp_1],#609CBB0000CB00BE00104000803EE875188B460103C683C0053B432C750B89350000CB00E80F0000004681FE0050660072DA9D619090909060BD0000CB00A10000CB00894510BB0000CB008B480103C883C1053B4B2C740861C3909090909090#
// Патч 2
add temp_1,60
mov [temp_1],#8B45102B43148B55102B53242B93E00000008955F83B43280F83880300008D53408955E88B53188955F48B551083C2058A123293E00000008BFA81E7FF00000025FF00000033F83B7DF40F87470200008B83E4000000F7EF0343548945FC8B45E80FB6008D04408B7483688B45FCFFD68BF03B75F80F850D020000807B20000F84DC0000008B45E80FB640098D04408B5483688B45FCFFD23C010F85C10000008D75FC33C08A43478D04408BD38B7C82688B06FFD78945EC33C08A43488D04408BD38B7C82688B06FFD78945E833C08A43428D04408BD38B7C82688B06FFD78BF833C08A43468D04408BD38B5482688B06FFD28845DF8BC303BBE00000005733C08A45DF05FF000000508BC3E8000000008BC88BC38B50108BC3E8000000008945D833C08A43438D04408BD38B7C82688B06FFD78BF88BC303BBE00000008B45EC03C70345D88945EC8B45E82BC72B45D88945E88B7DE8E9F70100009090909090#
// Патч 3
add temp_1,161
mov [temp_1],#8D75FC33C08A43428D04408BD38B7C82688B06FFD78945E833C08A43438D04408BD38B7C82688B06FFD78BF833C08A43458D04408BD38B5482688B06FFD28845E733C08A43418D04408BD38B5482688B06FFD28845EF8BC38B80E00000000345E88945D433C08A43478D04408BD38B5482688B06FFD28945E08BC303B8E00000005733C08A45E705FF000000508BC3E8000000008BC88BC38B50108BC3E8000000008945D033C08A43488D04408BD38B7C82688B06FFD78BF88B45D00145E08B4510402B382B7DD08B45100FB60003F88BC38B402C2B451083E80503F8E910010000909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090909090#
// Патч 4
add temp_1,127
mov [temp_1],#81C7FF0000003B7DF40F86B9FDFFFF8B83080100008B401C488945F48B43188B55F4423BC27405E9F20000008B45F485C00F8CE7000000408945E4C745EC000000008B83080100008B55ECE8630000008BF88B45E80FB6008D04408B7483688B4704FFD68BF03B75F87536807B200074218B45E80FB640098D04408B5483688B4704FFD23C01750A83C7048BF7E989FDFFFF83C7048BF7E940FEFFFF9090909090FF45ECFF4DE47599EB73909090909090909033C985D27C0B3B501C7D068B40188B0C908BC1C390909090E82A000000B9FF1500008B451066890883C0028930FF050000CB0061C3909090909090909090909090909090909090BE00506600393E740D83C61081FEF05F66007710EBEF83C6048B36C3909090909090909090#

mov temp_1,Address_Inject                                        // Копируем в переменную temp_1 значение Address_Inject
add temp_1,3                                                     // Получаем адрес для записи адреса таблицы, управляющей извлечением информации из массива данных
mov [temp_1],massive_APIS                                        // Записываем в прививку адрес массива данных с эмулированными APIs
add temp_1,5                                                     // Получаем адрес для записи начальный адрес главной области кода файла
mov [temp_1],VirtualAddress_1_sec                                // Записываем в прививку начальный адрес главной области кода программы
add temp_1,18                                                    // Получаем адрес для записи области памяти, куда будут записываться значения регистра ESI
mov temp_2,Address_Inject                                        // Копируем в переменную temp_2 значение Address_Inject
add temp_2,800                                                   // Указываем адрес ячейки памяти для записи значения регистра ESI
mov [temp_1],temp_2                                              // Записываем в прививку ячейки памяти для записи значения регистра ESI
add temp_1,0c                                                    // Получаем адрес для записи конечного адреса главной области кода программы
mov temp_2,VirtualAddress_1_sec                                  // Копируем в переменную temp_2 адрес секции кода программы
add temp_2,VirtualSize_1_sec                                     // Получаем адрес конца секции кода программы
mov [temp_1],temp_2                                              // Записываем в прививку адрес конца секции кода программы
add temp_1,0e                                                    // Получаем адрес для записи адреса области вспомогательного стека Asprotect.dll
mov temp_2,Address_Inject                                        // Копируем в переменную temp_2 значение Address_Inject
add temp_2,500                                                   // Указываем адрес области вспомогательного стека Asprotect.dll
mov [temp_1],temp_2                                              // Записываем в прививку адрес области вспомогательного стека Asprotect.dll
add temp_1,5                                                     // Получаем адрес для записи адреса ячейки памяти для записи значения регистра ESI
mov temp_2,Address_Inject                                        // Копируем в переменную temp_2 значение Address_Inject
add temp_2,800                                                   // Указываем адрес ячейки памяти для записи значения регистра ESI
mov [temp_1],temp_2                                              // Записываем в прививку адрес ячейки памяти для записи значения регистра ESI
add temp_1,8                                                     // Получаем адрес для записи адреса таблицы, управляющей извлечением информации из массива данных
mov [temp_1],massive_APIS                                        // Записываем в прививку адрес массива данных с эмулированными APIs
add temp_1,125                                                   // Получаем адрес расположения CALL с константой CONST в первой ветке кода
eval "{call_const}"                                              // Оцениваем значение CALL, которое мы сохранили в переменной call_const
asm temp_1,$RESULT                                               // Записываем этот CALL в нашей прививке
add temp_1,0e                                                    // Получаем адрес расположения CALL, в котором в цикле вычисляется хэш эмулированной API, вызываемой из конкретного кода программы
eval "{call_decrypt}"                                            // Оцениваем значение CALL, которое мы сохранили в переменной call_decrypt
asm temp_1,$RESULT                                               // Записываем этот CALL в нашей прививке
add temp_1,0d6                                                   // Получаем адрес расположения CALL с константой CONST во второй ветке кода
eval "{call_const}"                                              // Оцениваем значение CALL, которое мы сохранили в переменной call_const
asm temp_1,$RESULT                                               // Записываем этот CALL в нашей прививке
add temp_1,0e                                                    // Получаем второй адрес расположения CALL, в котором в цикле вычисляется хэш эмулированной API, вызываемой из конкретного кода программы
eval "{call_decrypt}"                                            // Оцениваем значение CALL, которое мы сохранили в переменной call_decrypt
asm temp_1,$RESULT                                               // Записываем этот CALL в нашей прививке
add temp_1,16c                                                   // Получаем адрес расположения счетчика восстановленных инструкций вызовов API
mov temp_2,Address_Inject                                        // Копируем в переменную temp_2 значение Address_Inject
add temp_2,804                                                   // Указываем адрес счетчика восстановленных инструкций вызовов API
mov [temp_1],temp_2                                              // Записываем в прививку адрес счетчика восстановленных инструкций вызовов API
add temp_1,19                                                    // Получаем адрес для записи начального адреса вспомогательной таблицы (начало секции файла .adata)
mov [temp_1],Add_Table_IAT                                       // Записываем в прививку начальный адрес вспомогательной таблицы
add temp_1,0d                                                    // Получаем адрес для записи конечного адреса вспомогательной таблицы
mov temp_2,Add_Table_IAT                                         // Копируем в переменную temp_2 начальный адрес вспомогательной таблицы
add temp_2,size_IAT                                              // Получаем адрес конца поиска значений во вспомогательной таблицы
mov [temp_1],temp_2                                              // Записываем в прививку конечный адрес вспомогательной таблицы
mov temp_3,Address_Inject                                        // Копируем в переменную temp_3 значение Address_Inject
add temp_3,3b9                                                   // Указываем адрес записи байтов опкода
cmp Flag_FF15,0                                                  // Проверяем значение переменной Flag_FF15
jne write_Flag_FF15_3                                            // Если здесь записана 1, то прыгаем на метку write_Flag_FF15_2
mov [temp_3],25ff                                                // Записываем байты опкода FF25
jmp write_bp_1                                                   // Прыгаем на продолжение корректировки прививки

write_Flag_FF15_3:
mov [temp_3],15ff                                                // Записываем байты опкода FF15

write_bp_1:
mov temp_2,Address_Inject                                        // Записываем в переменную temp_2 значение Address_Inject
add temp_2,37                                                    // Указываем адрес для установки bp при завершении работы прививки
mov temp_1,temp_2                                                // Записываем адрес для установки bp при завершении работы прививки
bp temp_2                                                        // Устанавливаем bp
add temp_2,3cf                                                   // Указываем адрес для установки bp при сбое в работе прививки
bp temp_2                                                        // Устанавливаем bp
cmp ver_132,1                                                    // Проверяем, не работаем ли мы с версией Asprotect 1.32 
jne run_code_2                                                   // Если НЕТ, прыгаем на запуск прививки
mov temp_1,Address_Inject                                        // Копируем в переменную temp_1 значение Address_Inject
add temp_1,2f7                                                   // Смещаемся на 2F7h байтов
mov [temp_1],#8B830401#                                          // Корректируем код прививки
add temp_1,33                                                    // Смещаемся на 33h байтов
mov [temp_1],#8B830401#                                          // Корректируем код прививки

// Восстановление оригинальный инструкций вызовов APIs вместо переадресованных инструкций
run_code_2:
mov temp_3,eip                                                   // Копируем в переменную temp_3 значение регистра EIP
mov eip,Address_Inject                                           // Устанавливаем регистр на начало прививки
run	                                                         // Запускаем программу
cmp eip,temp_1                                                   // Проверяем, остановилась ли программа на завершении работы прививки
je finish                                                        // Если ДА, то прыгаем на завершение работы скрипта
cmp eip,temp_2
je alarm                                                         // Если НЕТ, то прыгаем на предупреждение

finish:
bc eip	                                                         // Удаляем установленную bp
bc temp_2                                                        // Удаляем установленную bp
mov eip,temp_3                                                   // Возвращаемся на OEP программы
mov temp_1,Address_Inject                                        // Копируем в переменную temp_2 значение Address_Inject
add temp_1,804                                                   // Указываем адрес счетчика восстановленных инструкций вызовов API
mov count_type_1,[temp_1]                                        // Записываем в переменную число восстановленных инструкций вызовов APIs
fill Address_Inject,900,00                                       // Удаляем прививку
mov temp_1,[massive_APIS+18]                                     // Записываем число эмулированных вызовов API из таблицы массива данных с эмулированными APIs
mov temp_2,count_type_1                                          // Записываем в переменную temp_2 число восстановленных вызовов APIs первого типа
add temp_2,count_type_2                                          // Прибавляем число восстановленных вызовов APIs второго типа
cmp temp_2,temp_1                                                // Сравниваем полученное и табличное значения
jne warning
jmp end                                                          // Прыгаем на завершение работы скрипта

alarm:
msg "Сбой при работе прививки! Проверьте корректность введенных данных"
pause                                                            // Пауза в работе скрипта
jmp end                                                          // Прыгаем на завершение работы скрипта

warning:
msg "Внимание! Были восстановлены не все вызовы эмулированных APIs"
pause                                                            // Пауза в работе скрипта
jmp end                                                          // Прыгаем на завершение работы скрипта

error:
msg "Ошибка! Попытайтесь вручную найти нужную цепочку байтов."
pause                                                            // Пауза в работе скрипта

end:
ret	                                                         // Завершаем работу скрипта

no_recovery_CALL_APIs:
msg "В этой программе НЕТ переадресованных APIs!"                // Выводим сообщение
ret                                                              // Завершаем работу скрипта 
