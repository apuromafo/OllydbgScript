// Восстановление таблицы INIT
// Разработан - vnekrilov
// Установить флажки на все исключения отладчика
// Удалить все установленные breakpoints
// Тестировался только на WinXP
// Поддерживает Asprotect 1.32, 1.33, ,1.35, 1.4, 2.0, 2.1, 2.11, 2.2beta, 2.2, 2.3, 2.4, 2.41

var ImageBase_Asprotect_dll                     // Переменная для хранения значения ImageBase Asprotect.dll
var ImageBase_Module                            // Переменная для хранения значения ImageBase программы
var PE_signature                                // Переменная для хранения адреса PE-signature
var SizeOfImage                                 // Переменная для хранения значения SizeOfImage 
var Resource_Table                              // Переменная для хранения адреса Resource Table
var VirtualSize_1_sec                           // Переменная для хранения значения VirtualSize 1-й секции
var VirtualAddress_1_sec                        // Переменная для хранения значения VirtualAddress 1-й секции
var VirtualSize_Asprotect_sec                   // Переменная для хранения значения VirtualSize предпоследней секции файла, в которой находятся упакованные данные программы
var VirtualAddress_Asprotect_sec                // Переменная для хранения значения VirtualAddress предпоследней секции файла, в которой находятся упакованные данные программы
var VirtualSize_last_sec                        // Переменная для хранения значения VirtualSize последней секции
var VirtualAddress_last_sec                     // Переменная для хранения значения VirtualAddress последней секции
var write_INIT                                  // Переменная для хранения адреса подпрограммы записи таблицы INIT
var value_EIP                                   // Переменная для хранения значения регистра EIP
var start_INIT                                  // Переменная для хранения адреса начала таблицы INIT
var end_INIT                                    // Переменная для хранения адреса конца таблицы INIT
var Count_INIT                                  // Переменная для хранения количества элементов таблицы INIT
var Address_INIT                                // Переменная для хранения адреса подпрограммы инициализации INIT
var Address_DeINIT                              // Переменная для хранения адреса подпрограммы деинициализации INIT
var Massive_INIT                                // Переменная для хранения адреса массива с данными инициализации таблицы INIT
var Massive_DeINIT                              // Переменная для хранения адреса массива с данными деинициализации таблицы INIT
var Decrypt_INIT                                // Переменная для хранения адреса подпрограммы для раскриптовки элементов таблицы INIT
var CALL_Decrypt_INIT                           // Переменная для хранения адреса CALL Exx, который выполняет раскриптованную подпрограмму
var Recovery_INIT                               // Переменная для хранения адресов восстановленных элементов таблицы INIT
var Increment_Address                           // Величина приращения адресов подпрограмм инициализации (INIT) и деинициализации (DeINIT)
var CALL_Exx                                    // Переменная для хранения адреса назначения CALL Decrypt_INIT
var Address_EIP                                 // Переменная для хранения адреса EIP
var OEP_SBOEP_programm                          // Переменная для хранения OEP (SBOEP) программы
var Ver_141_0401                                // Переменная для хранения идентификатора версии 1.41 build 04.01 протектора
var Address_Inject                              // Переменная для хранения адреса размещения прививок
var temp_1
var temp_2
var temp_3
var temp_4

//Получение данных о секциях программы
BPHWCALL	                                // Удаляем все установленные Hardware Breakpoint
gmi eip,MODULEBASE                              // Получаем значение ImageBase программы
mov ImageBase_Module,$RESULT                    // Сохраняем значение ImageBase программы
mov temp_1,ImageBase_Module                     // Записываем в переменную temp_1 значение ImageBase программы
add temp_1,3c                                   // Переходим на адрес PE-signature
mov temp_1,[temp_1]                             // Записываем offset адрес PE-signature
add temp_1,ImageBase_Module                     // Получаем адрес PE-signature
mov PE_signature,temp_1                         // Сохраняем адрес PE-signature в переменной
add temp_1,50                                   // Получаем адрес записи SizeOfImage в PE-signature
mov SizeOfImage,[temp_1]                        // Сохраняем значение SizeOfImage
add temp_1,38                                   // Получаем адрес записи Resource Table в PE-signature
mov temp_2,[temp_1]                             // Записываем offset адреса Resource Table
add temp_2,ImageBase_Module                     // Получаем адрес Resource Table
mov Resource_Table,temp_2                       // Сохраняем адрес Resource Table 
add temp_1,70                                   // Получаем адрес начала секций в PE-signature
add temp_1,8                                    // Получаем адрес VirtualSize первой секции в PE-signature
mov VirtualSize_1_sec,[temp_1]                  // Записываем значение VirtualSize первой секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress первой секции в PE-signature  
mov VirtualAddress_1_sec,[temp_1]               // Записываем offset адреса VirtualAddress первой секции
add VirtualAddress_1_sec,ImageBase_Module       // Записываем значение адреса VirtualAddress первой секции
mov temp_1,PE_signature                         // Записываем адрес PE-signature
add temp_1,f8                                   // Получаем адрес начала секций в PE-signature
mov temp_2,[PE_signature+6]                     // Получаем значение числа секций файла в PE-signature
and temp_2,0FFFF                                // Получаем значение числа секций файла в PE-signature

last_sec:
cmp temp_2,1                                    // Сравниваем счетчик числа секций с 1 (последняя секция файла) 
je parametr_last_sec                            // Когда получаем адрес последней секции файла, прыгаем на запись ее параметров
add temp_1,28                                   // Получаем адреса начала секций в PE-signature
sub temp_2,1                                    // Переходим на следующую секцию
jmp last_sec                                    // Повторяем цикл

parametr_last_sec:
add temp_1,8                                    // Получаем адрес значения VirtualSize последней секции
mov VirtualSize_last_sec,[temp_1]               // Записываем значение VirtualSize последней секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress последней секции в PE-signature 
mov temp_3,[temp_1]                             // Записываем offset адреса VirtualAddress последней секции   
add temp_3,ImageBase_Module                     // Записываем значение адреса VirtualAddress последней секции
mov VirtualAddress_last_sec,temp_3              // Сохраняем в переменной значение адреса VirtualAddress последней секции

mov temp_1,PE_signature                         // Записываем адрес PE-signature
add temp_1,f8                                   // Получаем адрес начала секций в PE-signature
mov temp_2,[PE_signature+6]                     // Получаем значение числа секций файла в PE-signature
and temp_2,0FFFF                                // Получаем значение числа секций файла в PE-signature

Asprotect_sec:
cmp temp_2,2                                    // Сравниваем счетчик числа секций с 2 (предпоследняя секция файла) 
je parametr_Asprotect_sec                       // Когда получаем адрес предпоследней секции файла, прыгаем на запись ее параметров
add temp_1,28                                   // Получаем адреса начала секций в PE-signature
sub temp_2,1                                    // Переходим на следующую секцию
jmp Asprotect_sec                               // Повторяем цикл

parametr_Asprotect_sec:
add temp_1,8                                    // Получаем адрес значения VirtualSize предпоследней секции
mov VirtualSize_Asprotect_sec,[temp_1]          // Записываем значение VirtualSize предпоследней секции
add temp_1,4                                    // Получаем offset адреса VirtualAddress предпоследней секции в PE-signature 
mov temp_3,[temp_1]                             // Записываем offset адреса VirtualAddress предпоследней секции   
add temp_3,ImageBase_Module                     // Записываем значение адреса VirtualAddress предпоследней секции
mov VirtualAddress_Asprotect_sec,temp_3         // Сохраняем в переменной значение адреса VirtualAddress предпоследней секции

gpa "GetSystemTime","kernel32.dll"              // Получаем адрес API GetSystemTime на нашей машине
bp $RESULT                                      // Устанавливаем bp на API GetSystemTime
esto                                            // Выполняем команду SHIFT+F9 в OllyDbg
bc eip                                          // Удаляем bp на API GetSystemTime
rtr                                             // Выполняем API GetSystemTime до инструкции RETN
sti                                             // Выходим из API GetSystemTime
GMEMI eip,MEMORYOWNER                           // Получаем значение ImageBase Asprotect.dll
mov temp_1,$RESULT                              // Сохраняем полученное значение в переменной temp_1
cmp temp_1,ImageBase_Module                     // Сравниваем полученное значение с ImageBase программы
je write_ImageBase_Asprotect_dll                // Если они равны, прыгаем на метку write_ImageBase_Asprotect_dll
mov ImageBase_Asprotect_dll,temp_1              // Сохраняем значение ImageBase Asprotect.dll
jmp next                                        // Прыгаем на продолжение работы скрипта

write_ImageBase_Asprotect_dll:
mov temp_1,VirtualAddress_Asprotect_sec         // Записываем в переменную temp_1 значение VirtualAddress предпоследней секции        
mov ImageBase_Asprotect_dll,temp_1              // Сохраняем значение ImageBase Asprotect.dll
mov Ver_141_0401,1                              // Записываем флажок 1, который указывает нам на то, что используется версия 1.41 build 04.01 протектора

next:
// Ищем волнебную точку для восстановления таблицы INIT
find ImageBase_Asprotect_dll,#0036300D0A#              // Ищем ссылку на строку ASCII ошибки "60"
mov temp_1,$RESULT                                     // Записываем найденный адрес в переменную temp_1
cmp temp_1,0                                           // Проверяем, нашли ли мы эту строку
je error                                               // Если нет, прыгаем на ошибку
mov temp_2,temp_1                                      // Записываем найденный адрес в переменную temp_2
sub temp_2,90                                          // Вычитаем из найденного адреса 90h байтов
find temp_2,#C600??#                                   // Ищем инструкцию "mov [eax],??"
mov temp_3,$RESULT                                     // Записываем найденное значение в переменную temp_3
cmp temp_3,0                                           // Проверяем, найдена ли эта инструкция
je find_mov_eax                                        // Если НЕТ, то прыгаем на метку find_mov_eax
cmp temp_3,temp_1                                      // Сравниваем значения переменных temp_3 и temp_1
jb find_je_xxxxxxxx                                    // Если temp_3 < temp_1, то прыгаем, а если temp_3 > temp_1, то не прыгаем

find_mov_eax:
find temp_2,#C700D?000000#                             // Ищем инструкцию "mov [eax],d?"
mov temp_3,$RESULT                                     // Записываем найденный адрес в переменную temp_3
cmp temp_3,0                                           // Проверяем, найдена ли эта инструкция
je error                                               // Если нет, прыгаем на ошибку
cmp temp_3,temp_1                                      // Сравниваем значения переменных temp_3 и temp_1
ja error                                               // Если temp_3 > temp_1, то прыгаем на ошибку

find_je_xxxxxxxx:
find temp_3,#74??#                                     // Ищем инструкцию "je xxxxxxxx"
mov temp_4,$RESULT                                     // Записываем найденный адрес в переменную temp_4
cmp temp_4,0                                           // Проверяем, найдена ли эта инструкция
je error                                               // Если нет, прыгаем на ошибку
cmp temp_4,temp_1                                      // Сравниваем значения переменных temp_4 и temp_1
ja error                                               // Если temp_4 > temp_1, то прыгаем на ошибку
bphws temp_4,"x"                                       // Устанавливаем Hardware bp на эту инструкцию
run                                                    // Запускаем программу
cmp eip,temp_4                                         // Проверяем, остановились ли мы на bp
jne error                                              // Если нет, прыгаем на ошибку
bphwc eip                                              // Удаляем установленную Hardware bp
cmp !zf,0                                              // Проверяем значение флага Z
jne message                                            // Если Z=0, то не прыгаем
sti                                                    // Выполняем F7 в отладчике
sti                                                    // Выполняем F7 в отладчике
sti                                                    // Выполняем F7 в отладчике

// Получение основных данных о таблице INIT
mov start_INIT,[eax]                                   // Записываем в переменную offset адреса начала таблицы INIT
add start_INIT,ImageBase_Module                        // Прибавляем к адресу значение ImageBase программы
log start_INIT,"Начало таблицы Delphi INIT - "         // Записываем в журнал регистрации адрес начала таблицы INIT
find ImageBase_Asprotect_dll,#55FFD784C07504#          // Ищем группу инструкций "push ebp", "call edi", "test al,al" и "jnz xxxxxxxx"
mov temp_1,$RESULT                                     // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                           // Проверяем, нашли ли мы цепочку байтов
je error                                               // Если нет, прыгаем на ошибку
find temp_1,#837D0?0075E5#                             // Ищем группу инструкций "cmp dword [ebp+?],0", "jnz xxxxxxxx"
mov temp_2,$RESULT                                     // Записываем результат поиска в переменную temp_2
cmp temp_2,0                                           // Проверяем, нащли ли мы цепочку байтов
je error                                               // Если нет, прыгаем на ошибку
sub temp_2,2                                           // Вычитаем из найденного адреса 2 байта
bp temp_2                                              // Устанавливаем bp на адрес найденной подпрограммы
run                                                    // Запускаем программу
cmp eip,temp_2                                         // Проверяем, остановились ли мы на bp
jne error                                              // Если нет, прыгаем на ошибку
mov Massive_INIT,edx                                   // Записываем в переменную адрес массива с данными инициализации таблицы INIT
run                                                    // Запускаем программу
mov Massive_DeINIT,edx                                 // Записываем в переменную адрес массива с данными деинициализации таблицы INIT
run                                                    // Запускаем программу
mov Decrypt_INIT,edx                                   // Записываем в переменную адрес подпрограммы для раскриптовки элементов таблицы INIT
bc temp_2                                              // Удаляем bp
mov temp_1,start_INIT                                  // Записываем в переменную temp_1 адреса начала таблицы INIT
add temp_1,4                                           // Смещаемся на 4 байта, чтобы получить адрес, который указывает на подпрограммы инициализации и деинициализации таблицы INIT
mov temp_2,[temp_1]                                    // Записываем в переменную адрес, на котором находятся адреса подпрограмм инициализации и деинициализации таблицы INIT
mov Address_INIT,[temp_2]                              // Записываем в переменную адрес подпрограммы инициализации таблицы INIT
add temp_2,4                                           // Смещаемся на 4 байта, чтобы получить адрес подпрограммы деинициализации таблицы IAT
rtr                                                    // Выполняем подпрограмму до инструкции RETN
sti                                                    // Выполняем F7 в OllyDbg
rtr                                                    // Выполняем подпрограмму до инструкции RETN

// Определение адреса назначения CALL для выполнения раскриптованного CALL в таблице INIT
mov Address_DeINIT,[temp_2]                            // Записываем в переменную адрес подпрограммы деинициализации таблицы INIT
find Decrypt_INIT,#FFD0#                               // Ищем инструкцию CALL EAX
mov temp_3,$RESULT                                     // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                           // Проверяем, нашли ли эту цепочку байтов
jne call_EAX                                           // Если нет, то переходим на поиск CALL ECX
find Decrypt_INIT,#FFD1#                               // Ищем инструкцию CALL ECX
mov temp_3,$RESULT                                     // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                           // Проверяем, нашли ли эту цепочку байтов
jne call_ECX                                           // Если нет, то переходим на поиск CALL EDX
find Decrypt_INIT,#FFD2#                               // Ищем инструкцию CALL EDX
mov temp_3,$RESULT                                     // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                           // Проверяем, нашли ли эту цепочку байтов
jne call_EDX                                           // Если нет, то переходим на поиск CALL EВX
find Decrypt_INIT,#FFD3#                               // Ищем инструкцию CALL EBX
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, нашли ли эту цепочку байтов
jne call_EBX                                                      // Если нет, то переходим на поиск CALL ESP
find Decrypt_INIT,#FFD4#                                          // Ищем инструкцию CALL ESP
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, нашли ли эту цепочку байтов
jne call_ESP                                                      // Если нет, то переходим на поиск CALL EBP
find Decrypt_INIT,#FFD5#                                          // Ищем инструкцию CALL EBP
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, нашли ли эту цепочку байтов
jne call_EBP                                                      // Если нет, то переходим на поиск CALL ESI
find Decrypt_INIT,#FFD6#                                          // Ищем инструкцию CALL ESI
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, нашли ли эту цепочку байтов
jne call_ESI                                                      // Если нет, то переходим на поиск CALL EDI
find Decrypt_INIT,#FFD6#                                          // Ищем инструкцию CALL ESI
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, нашли ли эту цепочку байтов
jne call_EDI                                                      // Если Да, то прыгаем на call_EDI

call_EAX:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL EAX
mov CALL_Exx,"eax"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_ECX:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL ECX
mov CALL_Exx,"ecx"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_EDX:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL EDX
mov CALL_Exx,"edx"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_EBX:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL EBX
mov CALL_Exx,"ebx"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_ESP:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL ESP
mov CALL_Exx,"esp"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_EBP:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL EBP
mov CALL_Exx,"ebp"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_ESI:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL ESI
mov CALL_Exx,"esi"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

call_EDI:
mov CALL_Decrypt_INIT,temp_3                                      // Записываем в переменную адрес расположения CALL EDI
mov CALL_Exx,"edi"                                                // Записываем в переменную адрес регистра, где записан раскриптованный адрес CALL
jmp path_recovery_INIT                                            // Прыгаем на запись прививки для восстановления таблицы INIT

// Запись прививки для восстановления элементов таблицы INIT
path_recovery_INIT:
alloc 2000                                                        // Создаем область памяти для размещения кода привовок
mov Address_Inject,$RESULT                                        // Записываем в переменную полученный адрес созданной области памяти
mov temp_1,Address_Inject                                         // Записываем в переменную temp_1 адрес области памяти для размещения кода привовок
mov [temp_1],#609CE8F96FD9FFE8F46FD9FF9D61C3909090909090#         // Записываем код прививки
add temp_1,2                                                      // Смещаемся на адрес записи значения Address_INIT
eval "call {Address_INIT}"                                        // Оцениваем значение CALL Address_INIT
asm temp_1,$RESULT                                                // Записываем полученное значение CALL Address_INIT
add temp_1,5                                                      // Смещаемся на адрес записи значения Address_DeINIT
eval "call {Address_DeINIT}"                                      // Оцениваем значение CALL Address_DeINIT
asm temp_1,$RESULT                                                // Записываем полученное значение CALL Address_DeINIT
mov temp_1,Address_Inject                                         // Записываем значение ImageBase Address_Inject
add temp_1,7                                                      // Указываем адрес установки 1-й bp на инструкции CALL Address_DeINIT
bp temp_1                                                         // Устанавливаем bp
mov temp_2,Address_Inject                                         // Записываем значение Address_Inject
add temp_2,0e                                                     // Указываем адрес установки 2-й bp на инструкции RETN
bp temp_2                                                         // Устанавливаем bp
mov temp_3,start_INIT                                             // Записываем в переменную адрес начала таблицы INIT
add temp_3,4                                                      // Смещаемся на 4 байта, чтобы указать второй адрес таблицы INIT
mov temp_4,temp_3                                                 // Записываем в переменную temp_4 значение temp_3
add temp_4,4                                                      // Вычисляем следующий адрес таблицы INIT
mov [temp_3],temp_4                                               // Записываем во второй адрес таблицы INIT вычисленное значение переменной temp_4
mov Count_INIT,0                                                  // Записываем в счетчик числа элементов INIT значение 0
mov Increment_Address,8                                           // Записываем в переменную величину приращения адресов адресов подпрограмм инициализации (INIT) и деинициализации (DeINIT)
mov Recovery_INIT,start_INIT                                      // Записываем в переменную значение адреса начала таблицы INIT
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
bphws CALL_Decrypt_INIT,"x"                                       // Устанавливаем Hardware bp на адрес расположения CALL Exx
mov Address_EIP,eip                                               // Сохраняем значение регистра EIP в переменной
mov eip,Address_Inject                                            // Переходим на прививку

// Определение ветки кода скрипта для восстановления таблицы INIT
scmpi CALL_Exx,"eax"                                   
je recovery_INIT_EAX                                              // Если Да, то прыгаем на ветку кода recovery_INIT_EAX
scmpi CALL_Exx,"ecx"                                   
je recovery_INIT_ECX                                              // Если Да, то прыгаем на ветку кода recovery_INIT_ECX
scmpi CALL_Exx,"edx"                                   
je recovery_INIT_EDX                                              // Если Да, то прыгаем на ветку кода recovery_INIT_EDX
scmpi CALL_Exx,"ebx"                                   
je recovery_INIT_EBX                                              // Если Да, то прыгаем на ветку кода recovery_INIT_EBX
scmpi CALL_Exx,"esp"                                   
je recovery_INIT_ESP                                              // Если Да, то прыгаем на ветку кода recovery_INIT_ESP
scmpi CALL_Exx,"ebp"                                   
je recovery_INIT_EBP                                              // Если Да, то прыгаем на ветку кода recovery_INIT_EBP
scmpi CALL_Exx,"esi"                                              
je recovery_INIT_ESI                                              // Если Да, то прыгаем на ветку кода recovery_INIT_ESI
scmpi CALL_Exx,"edi"                                   
je recovery_INIT_EDI                                              // Если Да, то прыгаем на ветку кода recovery_INIT_EDI


recovery_INIT_EAX:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_EAX                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],eax                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_EAX                                             // Прыгаем на повторение цикла

recovery_DeINIT_EAX:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_EAX                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_ECX:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_ECX                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],ecx                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_ECX                                             // Прыгаем на повторение цикла

recovery_DeINIT_ECX:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_ECX                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_EDX:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_EDX                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],edx                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_EDX                                             // Прыгаем на повторение цикла

recovery_DeINIT_EDX:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_EDX                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_EBX:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_EBX                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],ebx                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_EBX                                             // Прыгаем на повторение цикла

recovery_DeINIT_EBX:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_EBX                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_ESP:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_ESP                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],esp                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_ESP                                             // Прыгаем на повторение цикла

recovery_DeINIT_ESP:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_ESP                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_EBP:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_EBP                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],ebp                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_EBP                                             // Прыгаем на повторение цикла

recovery_DeINIT_EBP:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_EBP                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_ESI:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_ESI                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],esi                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_ESI                                             // Прыгаем на повторение цикла

recovery_DeINIT_ESI:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_ESI                                             // Прыгаем на восстановление адресов CALL DeINIT

recovery_INIT_EDI:
run                                                               // Запускаем программу
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на 1-й bp
je recovery_DeINIT_EDI                                            // Если ДА, то прыгаем на метку recovery_DeINIT
mov [Recovery_INIT],edi                                           // Записываем в таблицу INIT раскриптованный адрес CALL
add Recovery_INIT,Increment_Address                               // Указываем адрес записи значения следующего элемента таблицы INIT
inc Count_INIT                                                    // Увеличиваем счетчик на 1
add eip,2                                                         // Пропускаем выполнение инструкции CALL Exx
jmp recovery_INIT_EDI                                             // Прыгаем на повторение цикла

recovery_DeINIT_EDI:
cmp eip,temp_2                                                    // Проверяем, остановились ли мы на 2-й bp
je final_recovery_INIT                                            // Если ДА, то прыгаем на метку final_recovery_INIT
bc eip                                                            // Удаляем установленную bp на инструкции CALL Address_DeINIT
mov temp_1,temp_2                                                 // Указываем в переменной temp_1 адрес bp на инструкции RETN
sub Increment_Address,10                                          // Указываем приращение адресов с конца таблицы INIT
mov end_INIT,Recovery_INIT                                        // Записываем адрес конца таблицы INIT
mov [Recovery_INIT],0                                             // Заполняем последний адрес таблицы INIT разделительными нолями
add Recovery_INIT,4                                               // Смещаемся на первое значение DeINIT в таблице INIT
jmp recovery_INIT_EDI                                             // Прыгаем на восстановление адресов CALL DeINIT

final_recovery_INIT:
sub Recovery_INIT,4                                               // Переходим на начало адрес начала таблицы INIT
shr Count_INIT,1                                                  // 
inc Count_INIT                                                    // Увеличиваем на 1 счетчик числа элементов в таблице INIT
mov [Recovery_INIT],Count_INIT                                    // Записываем число элементов таблицы INIT в начало таблицы INIT
bc eip                                                            // Удаляем установленную bp
bphwc CALL_Decrypt_INIT                                           // Удаляем Hardware bp
mov eip,Address_EIP                                               // Возвращаем значение регистра EIP
mov temp_1,Address_Inject                                         // Копируем в переменную значение Address_Inject
fill temp_1,40,00                                                 // Удаляем записанную прививку

// Прохождение на OEP программы
mov temp_1,ImageBase_Asprotect_dll                                // Копируем в переменную значение ImageBase Asprotect.dll
add temp_1,1000                                                   // Смещаемся на величину заголовка Asprotect.dll
find temp_1,#3135330D0A#                                          // Ищем строку ASCII "153" 
mov temp_2,$RESULT                                                // Записываем адрес этой строки в переменную temp_2
sub temp_2,40                                                     // Смещаемся вверх на 40 байтов
find temp_2,#5?5?C3#                                              // Ищем группу инструкций "pop e?x", "pop e?x", "retn" в конце подпрограммы
mov temp_3,$RESULT                                                // Записываем адрес группы инструкций в переменную temp_3
cmp temp_3,0                                                      // Проверяем, найдена ли эта группа инструкций
je error                                                          // Если нет, прыгаем на ошибку
add temp_3,2                                                      // Прибавляем к найденному адресу 2 байта, чтобы получить адрес инструкции RETN
rtr                                                               // Выполняем подпрограмму проверки CRC до инструкции RETN
bp temp_3                                                         // Устанавливаем bp на найденный адрес инструкции RETN
run                                                               // Запускаем программу
bc eip                                                            // Удаляем bp
mov temp_1,ImageBase_Asprotect_dll                                // Копируем в переменную значение ImageBase Asprotect.dll
add temp_1,1000                                                   // Смещаемся на величину заголовка Asprotect.dll
find temp_1,#3130330D0A#                                          // Ищем строку ASCII "103"
mov temp_2,$RESULT                                                // Записываем адрес этой цепочки байтов в переменную temp_2
cmp temp_2,0                                                      // Проверяем, найдена ли эта строка
je error                                                          // Если нет, прыгаем на ошибку
find temp_2,#8D00C3#                                              // Ищем инструкции "lea eax,[eax]", "retn", которые расположены ниже строки ASCII "103"
mov temp_1,$RESULT                                                // Записываем адрес этой группы инструкций в переменную temp_2
cmp temp_1,0                                                      // Проверяем, найдена ли эта группа инструкций
je error                                                          // Если НЕТ, прыгаем на ошибку
bphws temp_1,"x"                                                  // Устанавливаем Hardware BreakPoint на адрес этой группы инструкций
run                                                               // Запускаем программу
bphwc eip                                                         // Удаляем Hardware BreakPoint
find eip, #C700E1000000#                                          // Ищем строку ASCII "3.6"
mov temp_1,$RESULT                                                // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                                      // Проверяем, найдена ли эта строка
jne search_SBOEP                                                  // Если строка найдена, то прыгаем на метку search_SBOEP
find eip,#C600E1#                                                 // Если строка не найдена, то ищем инструкцию "mov byte:[eax],0e1"
mov temp_1,$RESULT                                                // Записываем результат поиска в переменную temp_1
cmp temp_1,0                                                      // Проверяем, найдена ли эта строка
je error                                                          // Если НЕТ, прыгаем на ошибку

search_SBOEP:
find temp_1, #A1????????894?#                                     // Ищем группу инструкций "mov eax,[const]", "mov [e?p+??],reg32"
mov temp_3,$RESULT                                                // Записываем результат поиска в переменную temp_3
cmp temp_3,0                                                      // Проверяем, найдена ли эта группа инструкций
je error                                                          // Если НЕТ, прыгаем на ошибку
mov temp_2,0                                                      // Обнуляем переменную temp_2
mov temp_2,[temp_3+1]                                             // Записываем адрес const в переменную temp_2 (содержимое const содержит адрес SBOEP)
mov temp_1,[temp_2]                                               // Записываем содержимое [const] в переменную temp_2
cmp temp_1,0                                                      // Проверяем, не записан ли здесь 0 (если записан 0, то код OEP не украден, и программа не имеет SBOEP)
jne SBOEP                                                         // Если записано значение SBOEP, то прыгаем на метку SBOEP

NO_SBOEP:
rtr                                                               // Выполняем подпрограмму до инструкции RETN
sti                                                               // Выполняем инструкцию RETN
GMEMI eip,MEMORYOWNER                                             // Получаем адрес памяти, где мы оказались после выполнения инструкции RETN
mov temp_3,$RESULT                                                // Полученный результат записываем в переменную temp_3
mov temp_2,VirtualAddress_last_sec                                // В переменную temp_2 записываем значение VirtualAddress_last_sec 
add temp_2,VirtualSize_last_sec                                   // К этому значению прибавляем значение VirtualSize_last_sec
cmp temp_3,temp_2                                                 // Проверяем, значение temp_3 больше или меньше значения temp_2
ja NO_SBOEP_1                                                     // Если больше, то прыгаем на метку NO_SBOEP_1
cmp VirtualAddress_1_sec,temp_3                                   // Если меньше, то сравниваем значения VirtualAddress_1_sec и temp_3
jb error                                                          // Если VirtualSize_1_sec > temp_3, то прыгаем на ошибку
GMEMI eip,MEMORYSIZE                                              // Получаем размер области памяти, где мы оказались после выполнения инструкции RETN
mov temp_1,$RESULT                                                // Полученное значение записываем в переменную temp_1
add temp_3,temp_1                                                 // Суммируем значения temp_3 и temp_1
eval "eip > 0{temp_3}"                                            // Получаем условие cnd, при котором оно будет TRUE
jmp NO_SBOEP_2                                                    // Прыгаем на метку NO_SBOEP_2

NO_SBOEP_1:
eval "eip < 0{temp_3}"                                            // Получаем условие cnd, при котором оно будет TRUE

NO_SBOEP_2:
ticnd $RESULT                                                     // Трассируем into calls до появления условия cnd TRUE
mov temp_1,eip                                                    // Записываем полученный адрес OEP в переменную temp_1
log temp_1,"Адрес OEP - "                                         // Записываем адрес OEP в журнал регистрации
jmp end                                                           // Прыгаем на завершение работы скрипта

SBOEP:
bp temp_1                                                         // Устанавливаем bp на адрес SBOEP
run                                                               // Запускаем программу

SBOEP_1:
cmp eip,temp_1                                                    // Проверяем, остановились ли мы на bp
je SBOEP_2                                                        // Если ДА, то прыгаем на метку SBOEP_2
run                                                               // Если НЕТ, то опять запускаем программу

SBOEP_2:
bc temp_1                                                         // Удаляем bp
mov temp_1,eip                                                    // Записываем полученный адрес SBOEP в переменную temp_1
log temp_1,"Адрес SBOEP - "                                       // Записываем адрес SBOEP в журнал регистрации
jmp end                                                           // Прыгаем на завершение работы скрипта

message:
msg "Таблица INIT не повреждена, или отсутствует!"                // Выводим сообщение об отсутствии необходимости в восстановлении таблицы INIT
ret                                                               // Завершаем работу скрипта

error:
msg "Ошибка! Попытайтесь вручную найти нужную цепочку байтов."    // Выводим сообщение об ошибке
ret                                                               // Завершаем работу скрипта 

end:
// Дампирование таблицы INIT
mov temp_1,start_INIT                                             // Записываем в переменную temp_1 адрес начала таблицы INIT
mov temp_2,end_INIT                                               // Записываем в переменную temp_2 адрес конца таблицы INIT
add temp_2,8                                                      // Прибавляем 8 байтов, для получения фактического адреса конца таблицы INIT
sub temp_2,temp_1                                                 // Получаем размер таблицы INIT
dm start_INIT,temp_2,"table_INIT.bin"                             // Дампируем таблицу INIT


// Запись в буфер памяти журнал OllyDbg основных значений для ImpREC и скрипта для восстановления вызовов APIs
log ImageBase_Asprotect_dll,"Адрес начала AsProtect.dll - "       // Записываем в журнал регистрации ImageBase Asprotect.dll
log start_INIT,"Адрес начала таблицы INIT - "                     // Записываем в журнал адрес начала таблицы INIT
add end_INIT,4                                                    // Прибавляем 4 байта, чтобы получить адрес конца таблицы IAT
log end_INIT,"Адрес конца таблицы INIT - "                        // Записываем в журнал адрес конца таблицы INIT
log Count_INIT, "Число элементов в таблице INIT - "               // Записываем число элементов в таблице INIT
ret                                                               // Завершаем работу скрипта 
